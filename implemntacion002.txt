# Resumen de Implementación: implemntacion002.txt

## Objetivo General
El objetivo de esta sesión fue transformar la sección de "Gestión de Menú" de una interfaz estática a una aplicación CRUD (Crear, Leer, Actualizar, Borrar) completamente funcional y persistente para las categorías. Además, se implementó la visualización de productos filtrados por la categoría seleccionada.

---

## Fase 1: Corrección de Arquitectura y Errores Iniciales

**Contexto:** La aplicación presentaba errores que impedían su arranque y el correcto funcionamiento de la carga de datos.

**Paso 1.1: Solución de Error de React Router**
*   **Problema:** La aplicación se rompía con el error `[GenericModal] is not a <Route> component`.
*   **Causa:** El componente `<GenericModal />` estaba incorrectamente anidado dentro del componente `<Routes>` en `App.jsx`.
*   **Solución:** Se movió `<GenericModal />` para que fuera un "hermano" de `<Routes>`, no un "hijo".
*   **Ubicación:** `/src/App.jsx`
*   **Implementación:**
    ```jsx
    // Estructura Corregida en App.jsx
    function App() {
      return (
        <>
          {/* ... otros componentes y lógica ... */}
    
          <Routes>
            {/* ... todas tus definiciones de <Route> ... */}
          </Routes>
    
          {/* El modal se coloca aquí, fuera de <Routes> */}
          <GenericModal />
        </>
      );
    }
    ```

**Paso 1.2: Solución de Error de "Non-Serializable Value" en Redux**
*   **Problema:** Al hacer clic en "Eliminar", la API era llamada con un ID `undefined`, y la consola de Redux advertía sobre un valor no serializable (`SyntheticBaseEvent`).
*   **Causa:** El `onClick` de los botones de acción estaba pasando el evento del clic a la función `handleDelete` en lugar del objeto `category`.
*   **Solución:** Se ajustó la llamada `onClick` para usar una función de flecha que pasara explícitamente el objeto `category` correcto.
*   **Ubicación:** `/src/components/admin/CategoryButtons.jsx`
*   **Implementación:**
    ```jsx
    // Llamada Corregida
    <button onClick={(e) => handleDelete(e, category)}>
      <RiDeleteBinLine />
    </button>

    // Función receptora
    const handleDelete = (e, category) => {
      e.stopPropagation(); // Se añadió para evitar clics no deseados
      dispatch(openModal({
        title: 'Confirmar Eliminación',
        contentKey: 'DELETE_CATEGORY_CONFIRM',
        data: category, // 'data' ahora recibe el objeto 'category' correcto
      }));
    };
    ```

---

## Fase 2: Implementación de API Real para CRUD de Categorías

**Contexto:** Se abandonó la "simulación" de API para implementar un backend real usando Vercel Serverless Functions que modifican permanentemente el archivo `categories.json`.

**Paso 2.1: API para LEER (`GET`)**
*   **Objetivo:** Crear un endpoint `/api/categories` que devuelva el contenido de `categories.json`.
*   **Archivo Creado:** `api/categories/index.js`
*   **Implementación (Backend):**
    ```javascript
    // en api/categories/index.js
    import path from 'path';
    import { promises as fs } from 'fs';

    export default async function handler(req, res) {
      if (req.method === 'GET') {
        const jsonFilePath = path.join(process.cwd(), 'public', 'api', 'categories.json');
        const fileContents = await fs.readFile(jsonFilePath, 'utf8');
        const data = JSON.parse(fileContents);
        res.status(200).json(data);
      }
      // ... (lógica para otros métodos)
    }
    ```
*   **Implementación (Frontend):** Se actualizó la llamada en el servicio para apuntar a la nueva ruta.
*   **Ubicación:** `/src/services/api.js`
    ```javascript
    export const getCategories = () => {
       return apiClient.get('categories'); // Se quitó el '.json'
    };
    ```

**Paso 2.2: API para BORRAR (`DELETE`)**
*   **Objetivo:** Crear un endpoint dinámico `/api/categories/[id]` que elimine una categoría del archivo `categories.json`.
*   **Archivo Creado:** `api/categories/[id].js`
*   **Implementación (Backend):**
    ```javascript
    // en api/categories/[id].js
    if (req.method === 'DELETE') {
      const { id } = req.query;
      // ... lógica para leer, filtrar el array y reescribir el archivo .json ...
      await fs.writeFile(jsonFilePath, JSON.stringify(newCategories, null, 2));
      return res.status(200).json({ message: 'Categoría eliminada.' });
    }
    ```
*   **Implementación (Frontend):** Se actualizó la función del servicio para hacer una petición `DELETE` real.
*   **Ubicación:** `/src/services/api.js`
    ```javascript
    export const deleteCategory = (categoryId) => {
      return apiClient.delete(`categories/${categoryId}`);
    };
    ```

**Paso 2.3: API para ACTUALIZAR (`PUT`)**
*   **Objetivo:** Añadir lógica al endpoint `/api/categories/[id].js` para manejar peticiones `PUT` y actualizar el nombre de una categoría.
*   **Archivo Modificado:** `api/categories/[id].js`
*   **Implementación (Backend):**
    ```javascript
    // en api/categories/[id].js
    if (req.method === 'PUT') {
      const { name: newName } = req.body;
      // ... lógica para leer, usar .map() para actualizar el array y reescribir el archivo .json ...
      await fs.writeFile(jsonFilePath, JSON.stringify(updatedCategories, null, 2));
      return res.status(200).json(updatedCategory);
    }
    ```
*   **Implementación (Frontend):** Se actualizó la función del servicio.
*   **Ubicación:** `/src/services/api.js`
    ```javascript
    export const updateCategory = ({ id, name }) => {
      return apiClient.put(`categories/${id}`, { name });
    };
    ```

**Paso 2.4: API para CREAR (`POST`)**
*   **Objetivo:** Añadir lógica al endpoint `/api/categories/index.js` para manejar peticiones `POST`, generar un nuevo ID y añadir una nueva categoría.
*   **Archivo Modificado:** `api/categories/index.js`
*   **Implementación (Backend):**
    ```javascript
    // en api/categories/index.js
    if (req.method === 'POST') {
      const { name } = req.body;
      // ... lógica para leer, generar nuevo ID, hacer .push() al array y reescribir el archivo .json ...
      await fs.writeFile(jsonFilePath, JSON.stringify(categories, null, 2));
      return res.status(201).json(newCategory);
    }
    ```
*   **Implementación (Frontend):** Se creó la función en el servicio y se conectó al modal.
*   **Ubicación:** `/src/services/api.js` y `/src/components/modals/GenericModal.jsx`
    ```javascript
    // en api.js
    export const createCategory = ({ name }) => {
      return apiClient.post('categories', { name });
    };

    // en GenericModal.jsx, dentro de CreateFormContent
    dispatch(createCategoryAsync({ name }));
    ```

---

## Fase 3: Mejoras de Interfaz de Usuario (UI/UX)

*   **Problema:** La lista de categorías se veía desordenada con todos los botones de acción visibles.
*   **Solución:** Se implementó un patrón de diseño común donde los botones "Editar" y "Eliminar" solo aparecen cuando el usuario pasa el cursor sobre el elemento de la lista correspondiente.
*   **Ubicación:** `/src/styles/components/admin/categoryButtons.scss`
*   **Implementación:**
    ```scss
    .containerCategories-btn {
      .containerCategories-btn-actions {
        // Ocultar por defecto
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease-in-out;
      }
      &:hover {
        // Mostrar en hover
        .containerCategories-btn-actions {
          opacity: 1;
          visibility: visible;
        }
      }
    }
    ```

---

## Fase 4: Visualización de Productos por Categoría (Estado Actual)

*   **Objetivo:** Mostrar una lista de productos que se filtra dinámicamente al seleccionar una categoría.
*   **Implementación:**
    1.  Se creó un nuevo componente `AdminProductsList`.
    2.  Este componente usa `useSelector` para obtener la lista de productos y el `selectedCategoryId` del estado de Redux.
    3.  Usa el hook `useMemo` para recalcular eficientemente la lista de productos filtrados solo cuando es necesario.
    4.  Renderiza una tabla con los productos filtrados.
    5.  Se integró el componente en la página `AdminMenuPage.jsx`.
*   **Ubicaciones Clave:**
    *   `/src/components/admin/AdminProductsList.jsx` (Nuevo componente)
    *   `/src/pages/admin/AdminMenuPage.jsx` (Integración)

**Hasta aquí hemos llegado. El CRUD de categorías es 100% funcional y persistente, y la visualización de productos por categoría está implementada.**
